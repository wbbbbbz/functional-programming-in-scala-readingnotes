# 4 不是用异常来处理错误

## 3.1 定义函数式数据结构

- 函数式数据结构，只能被纯函数操作（一定不能修改原始数据，不能产生副作用）
- 函数式数据结构被定义为不可变
- sealed关键字意味着这个特质的所有实现都必须定义在这个文件 
- trait List[+A]: +号代表协变，正向。也就是如果B是A的子类，则List[B]是List[A]的子类
- 单向链表
  - 最普遍。
  - Scala中的List
    - Cons代表数据结构器，传入非空初始元素head与后续的tail。
    - List(a, b) == Cons(a, Cons(b, Nil))

## 3.2 模式匹配
- 除了经常声明数据类型和数据构造器之外，我们也经常声明伴生对象。它只是与数据类型同名的一个单例（object），通常在里面定义一些用于创建或处理数据类型的便捷方法。

- 例子
  ```scala
  List(1,2,3) match {case _ => 42} // 42
  List(1,2,3) match {case Cons(h, _) => 1} // 42
  List(1,2,3) match {case Cons(_, t) => List(2, 3)} // 42
  List(1,2,3) match {case _ => 42} // 42

- 练习3-1
  ```scala
  val x = List(1, 2, 3, 4, 5) match {
    case Cons(x, Cons(2, Cons(4, _))) => x
    case Nil => 42
    case Cons(x, Cons(y, Cons(3, Cons(4, _)))) => x + y
    case Cons(h, t) => h + sum(t)
    case _ => 101
  }
  // x shouldBe 3
  ```

- 对一个数据类型，在伴生对象中定义一个可变参数的apply方法以便构造这个数据类型的实例是一种惯例。

## 3.3 函数式数据结构中的数据共享
> 当数据不可变时，我们该怎么写一些例如从list中删除元素之类的函数？答案很简单，当我们对一个已存在的列表xs在前面添加一个元素1的时候，返回一个新的列表，即Cons(1, xs)。既然列表是不可变的，我们不需要真的去复制一份xs，可以直接复用它，这也称为数据共享。共享不可变数据可以让函数实现更高的效率。我们可以返回不可变数据结构而不用担心后续代码修改它，不需要悲观地复制一份数据以避免对其修改或污染。

- 比如List的tail方法，只是指向了原始列表的尾部。因为都是不可变的，所以不需要防御性的拷贝

- 数据共享通常可以实现更好的性能

- 函数直接使用两个参数，和通过柯里化分开两个参数下，柯里化能更好的利用类型推导。因为参数的类型信息会从左到右传递

- Scala中foldLeft和foldRight其实本质上不一样。
  - foldRight属于从内到外，而foldLeft属于从外到内
  - 以前Scala中的foldRight不是stack安全的，因为递归调用不是尾调用(调用完之后还需要将列表连接)。所以需要用foldLeft进行reverse之后操作
  - 但是现在是stack安全了


> List的一个问题是，虽然我们可以按照非常通用的函数来表达操作和算法，但实现的结果往往不太高效。我们最终可能会对相同的输入进行多次传递，或者不得不写一些显式的递归循环，运行提前终止。
